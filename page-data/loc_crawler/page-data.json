{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/loc_crawler/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Justin's Data Blog"}},"markdownRemark":{"id":"c37f105a-dd41-5f18-9dd3-df41400006f2","excerpt":"Crawling the Library of Congress API Introduction The United States Library of Congress maintains a rest api for developers to crawl their collections.  It isâ€¦","html":"<h1>Crawling the Library of Congress API</h1>\n<h2>Introduction</h2>\n<p>The United States Library of Congress maintains a rest api for developers to crawl their collections.  It is an open source tool that anyone can access in order to conduct research. Check out the documenation at <a href=\"https://libraryofcongress.github.io/data-exploration/\">https://libraryofcongress.github.io/data-exploration/</a>.</p>\n<h2>Creating a crawler</h2>\n<p>I took the approach of writing a generator that produces a search result page object that can be operated upon with each iteration.</p>\n<p>The first step is to create a search result page object.</p>\n<p>The code below documents the search_result page.  It contains a number of helper functions to convert the nodes within the result to json or graphml.  The code can also be used to generate a networkx in memory graph.</p>\n<h3>The Search Result Object</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class search_results_page():\n\n    def __init__(self,base_url = \"https://www.loc.gov/collections\",collection = \"united-states-reports\",json_parameter = \"fo=json\",results_per_page = \"c=79\",query_param = \"?\",page_param =\"sp=\",page_num = 1):\n        #pprint(num_columns)\n        self.search_url = self.create_search_url(base_url,collection,json_parameter,results_per_page,query_param,page_param,page_num)\n        self.response = self.request_data()\n        self.response_json = self.response_to_json()\n        #self.soup_html = self.html_parse()\n        self.next_url = self.get_next_url()\n        self.page_num = page_num\n\n    def to_json(self, file_name = 'result_',file_num = 0, extension =\".json\"):\n        output_name = file_name + str(file_num)\n        output_name = output_name + extension\n        with open(output_name, 'w') as outfile:\n            json.dump(self.response_json, outfile)\n\n    def to_pandas(self):\n        df = nx.to_pandas_edgelist(self.graph)\n        return(df)\n\n    def to_csv(self,file_name = 'result_',file_num = 0, extension =\".csv\"):\n        output_name = file_name + str(file_num)\n        output_name = output_name + extension\n        df = self.to_pandas()\n        df.to_csv(output_name)\n\n\n    def write_graphml(self,file_name = 'result_', file_num=0, extension = \".graphml\"):\n        output_name = file_name + str(file_num)\n        output_name = output_name + extension\n        nx.write_graphml(self.graph, output_name)\n\n    def write_to_file(self,data = None, file_name = 'result_',file_num = 0, extension = \".json\"):\n        output_name = file_name + str(file_num)\n        output_name = output_name + extension\n        with open(output_name, 'w') as outfile:\n            json.dump(data, outfile)\n\n\n    def node_gen_2(self, data, root ='result', node_list = [], edge_list = [], previous_k = None, previous_edge = None, graph = None):\n        #root = root \n        if type(data) is dict:\n            for k, v in data.items():\n                if k is not None and k not in node_list:\n                    graph.add_node(k, type = k)\n                    #node_list.append((k, {'type' : k}))\n                    #(1, 2, color='red', weight=0.84, size=300)\\\n                    graph.add_edge(root,k, relationship = \"of\", type = \"root\")\n                    #edge_list.append((root , k, {\"relationship\" : \"of\"}, {\"type\" : 'root'}))\n                #pprint('passing_value')\n                #save k\n                previous_k = k\n                previous_edge = (root , k)\n                self.node_gen_2(v,root = root, node_list = node_list,edge_list = edge_list, previous_k = k, previous_edge = previous_edge, graph = graph)\n\n        elif type(data) is list:\n            for item in data:\n                #pprint('passing_data')\n\n                self.node_gen_2(item,root = root, node_list = node_list,edge_list = edge_list,previous_k = previous_k, previous_edge= previous_edge, graph = graph)\n                #create_edge to k\n\n        else:\n            #this item is no longer a dictionary or list\n            pprint('appending_data')\n            #create edge to k\n            if data is not None:\n                graph.add_node(data,type = data)\n                #node_list.append((data, {\"type\" : data}))\n                graph.add_edge(previous_k, data, relationship = \"is\", type = previous_k)\n                #edge_list.append((previous_k ,data,{'relationship': \"is\"}, {'type' : data}))\n                #edge_list.append((root,data))\n\n    #flatten(hierarchak)_dict)\n        return graph \n\n    \n    def node_runner(self,data,graph):\n        \n        node_list = []\n        edge_list = []\n        for item in data:\n            #root = item['title']\n            graph = self.node_gen_2(data = item, node_list = node_list, graph = graph)\n        #pprint(edge_list)\n        return graph\n\n    def node_generator(self, data, root ='title_testing', node_list = [], edge_list = [], previous_k = None, previous_edge = None):\n        #pprint(data)\n        if type(data) is dict:\n            for k, v in data.items():\n                if k is not None and k not in node_list:\n                    node_list.append(k)\n                    edge_list.append((root , k))\n                #pprint('passing_value')\n                #save k\n                previous_k = k\n                previous_edge = (root , k)\n                self.node_generator(v,root = root, node_list = node_list,edge_list = edge_list, previous_k = k, previous_edge = previous_edge)\n\n        elif type(data) is list:\n            for item in data:\n                #pprint('passing_data')\n\n                self.node_generator(item,root = root, node_list = node_list,edge_list = edge_list,previous_k = previous_k, previous_edge= previous_edge)\n                #create_edge to k\n\n        else:\n            #this item is no longer a dictionary or list\n            pprint('appending_data')\n            #create edge to k\n            if data is not None:\n                node_list.append(data)\n                edge_list.append((previous_k ,data))\n                edge_list.append((root,data))\n\n    #flatten(hierarchak)_dict)\n        return node_list, edge_list \n        #self.json_graph = self.create_json_graph()\n\n\n    def create_json_graph(self):\n        #graph = nx.Graph(self.response_json)\n        graph = nx.from_dict_of_dicts(self.response_json)\n        #graph = json_graph.node_link_graph(self.response_json)\n        nx.draw(graph)\n        return graph\n        \n        #self.node_list = self.node_generator`\n\n\n\n    def create_search_result_node(self):\n     \n        for item in self.response_json_flat:\n            for k,v in item.items():\n                if k not in self.column_lookup_table:\n                    column_string = self.colnum_string()\n\n                    self.column_lookup_table[k] = self.colnum_string(self.num_columns)\n                    self.num_columns += 1\n                else:\n                    continue\n\n    def append_to_data_list(self,rnge,d):#rename to _data_list\n        request_body = {\n            'range': rnge,\n            \"majorDimension\": \"COLUMNS\",\n            \"values\": [d]\n        }\n        return request_body\n        #data_list.append(request_body_tmp)\n\n    def map_column_to_range(self,column_key):\n        \n        rnge = \"'Sheet1'\" + \"!\" + column_key + str(1)\n        return rnge\n                \n\n    def colnum_string(self,num_columns):\n        string = \"\"\n        #pprint(\"conlum_string\")\n        #pprint(num_columns)\n        while num_columns > 0:\n            num_columns, remainder = divmod(num_columns - 1, 26)\n            string = chr(65 + remainder) + string\n            #pprint(string)\n        return string\n\n    def map_columns_to_lookup_table(self):\n\n        #print('first_map_columns_print')\n        #num_columns_tmp = self.num_columns\n        #pprint(num_columns_tmp)\n        for item in self.response_json_flat:\n            for k in item.keys():\n                num_columns_tmp = self.num_columns\n                if k not in self.column_lookup_table:\n                    #print('second_map_Columns_print')\n                    #pprint(num_columns_tmp)\n                    self.column_lookup_table[k] = self.colnum_string(num_columns = num_columns_tmp)\n                    self.num_columns = self.num_columns + 1\n       \n                    #append range to request... \n                    #append collumn to batch lookup\n                \n\n                else:\n                    continue\n    \n    def column_request_list_generator(self):\n        request_list = []\n        for k,v in self.column_lookup_table.items():\n            rnge = self.map_column_to_range(k)\n            request_body = self.append_to_data_list(rnge,v)\n            #pprint(request_body)\n            request_list.append(request_body)\n        return request_list\n\n\n\n\n\n        #return column_lookup_table\n\n    def get_next_url(self):\n        return (self.response_json['pagination']['next'])\n\n    def create_search_url(self,base_url,collection,json_parameter,results_per_page,query_param,page_param,page_num):\n        url_sep =\"/\"\n        page_param = page_param +(str(page_num))\n        query = \"&amp;\".join([json_parameter,results_per_page,page_param])\n        query = query_param + query\n        search_url = url_sep.join([base_url,collection,query])\n        #pprint(search_url)\n        \n        return search_url\n\n    def say_hello(self):\n        pprint(self.base_url)\n\n    def request_data(self):\n        headers = {'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.11 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9',\n                    'Accept-Encoding': 'identity'\n                }\n        return requests.get(self.search_url,headers=headers)\n\n    def response_to_json(self):\n        return self.response.json()\n\n    def html_parse(self):\n        soup=BeautifulSoup(self.response.content,'lxml')\n        #pprint(soup)\n        return soup\n\n    def flatten_result(self):\n        flat_result_list = []\n        for item in self.response_json['results']:\n            flat_json = flatten(item)\n            flat_result_list.append(flat_json)\n        return flat_result_list\n</code></pre></div>\n<h2>The Generator</h2>\n<p>The generator yields a search result page if the pagination link included in the response is valid.</p>\n<p>Depending on your use case you could pass the page_num and collection you would like to crawl.</p>\n<p>The api is limited to 80 results per minute.  The sleep function limits calls to the desired rate.  The amount of results returned can be passed to the search result page_object.  Review the code above to see which values can be passed.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def search_result_generator(condition = True):\n    #column_lookup_table = {}\n    #pprint(num_columns)\n    page_num = 1\n    column_lookup_table = {}\n    while condition ==True:\n        #pprint(num_columns)\n        time.sleep(61)\n        search_results_page_object = create_search_results_page_object(page_num = page_num)\n        if search_results_page_object.next_url != None:\n            condition = True\n            page_num = page_num + 1            \n            yield (search_results_page_object)\n        else:\n            condition = False\n            yield (search_results_page_object)</code></pre></div>\n<h2>The Runner Function</h2>\n<p>To initiate the crawl simply run the algorithm below.  It writes each result page to json.</p>\n<p>As a follow up project, I will post how to integrate the data returned into a neo4j database.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for obj in search_result_generator():   \n        page_num = obj.page_num\n        with cd(\"output_2\"):\n            #print('hahaha')\n            obj.to_json(file_num = page_num)\n            #obj.write_graphml(file_num= page_num)\n            #obj.to_pandas()\n            #obj.write_to_file(data = obj.dict_of_dicts, file_num = page_num)\n            #obj.to_csv()\n        write_last_page_num(page_num)\n        print(\"{} Search Results Crawled\".format(page_num))\n</code></pre></div>\n<h2>Putting Everything Together</h2>\n<p>The code below is the entire program as it stands.  There is built in functionality to upload the results to a google sheet if that is what you desire using an extension of the google api.   That code can be found at <a href=\"https://github.com/justin-napolitano/GoogleAPI\">https://github.com/justin-napolitano/GoogleAPI</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#library_of_congress_scraper.py\nfrom __future__ import print_function\nfrom bs4 import BeautifulSoup\nimport requests\nimport lxml.etree as etree\nimport xml.etree.ElementTree as ET\nimport json\nimport pandas as pd\nimport os\nimport time\nimport random\nimport math\nfrom pprint import pprint\n#import load_vars as lv\nimport html\nimport yaml\nfrom yaml import Loader, Dumper\nimport glob\nimport datetime\nimport os.path\nfrom googleapiclient.discovery import build\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom google.auth.transport.requests import Request\nfrom google.oauth2.credentials import Credentials\nfrom google.oauth2 import service_account\nfrom googleapiclient.http import MediaIoBaseDownload, MediaFileUpload\nfrom flatten_json import flatten\nimport networkx as nx\nimport matplotlib\nfrom networkx.readwrite import json_graph\nimport matplotlib.pyplot as plt\nimport tracemalloc\nimport os\n#from ratelimiter import RateLimiter\n\n\nclass cd:\n    \"\"\"Context manager for changing the current working directory\"\"\"\n    def __init__(self, newPath):\n        self.newPath = os.path.expanduser(newPath)\n\n    def __enter__(self):\n        self.savedPath = os.getcwd()\n        os.chdir(self.newPath)\n\n    def __exit__(self, etype, value, traceback):\n        os.chdir(self.savedPath)\n\nclass search_results_page():\n\n    def __init__(self,base_url = \"https://www.loc.gov/collections\",collection = \"united-states-reports\",json_parameter = \"fo=json\",results_per_page = \"c=79\",query_param = \"?\",page_param =\"sp=\",page_num = 1):\n        #pprint(num_columns)\n        self.search_url = self.create_search_url(base_url,collection,json_parameter,results_per_page,query_param,page_param,page_num)\n        self.response = self.request_data()\n        self.response_json = self.response_to_json()\n        #self.soup_html = self.html_parse()\n        self.next_url = self.get_next_url()\n        self.page_num = page_num\n\n    def to_json(self, file_name = 'result_',file_num = 0, extension =\".json\"):\n        output_name = file_name + str(file_num)\n        output_name = output_name + extension\n        with open(output_name, 'w') as outfile:\n            json.dump(self.response_json, outfile)\n\n    def to_pandas(self):\n        df = nx.to_pandas_edgelist(self.graph)\n        return(df)\n\n    def to_csv(self,file_name = 'result_',file_num = 0, extension =\".csv\"):\n        output_name = file_name + str(file_num)\n        output_name = output_name + extension\n        df = self.to_pandas()\n        df.to_csv(output_name)\n\n\n    def write_graphml(self,file_name = 'result_', file_num=0, extension = \".graphml\"):\n        output_name = file_name + str(file_num)\n        output_name = output_name + extension\n        nx.write_graphml(self.graph, output_name)\n\n    def write_to_file(self,data = None, file_name = 'result_',file_num = 0, extension = \".json\"):\n        output_name = file_name + str(file_num)\n        output_name = output_name + extension\n        with open(output_name, 'w') as outfile:\n            json.dump(data, outfile)\n\n\n    def node_gen_2(self, data, root ='result', node_list = [], edge_list = [], previous_k = None, previous_edge = None, graph = None):\n        #root = root \n        if type(data) is dict:\n            for k, v in data.items():\n                if k is not None and k not in node_list:\n                    graph.add_node(k, type = k)\n                    #node_list.append((k, {'type' : k}))\n                    #(1, 2, color='red', weight=0.84, size=300)\\\n                    graph.add_edge(root,k, relationship = \"of\", type = \"root\")\n                    #edge_list.append((root , k, {\"relationship\" : \"of\"}, {\"type\" : 'root'}))\n                #pprint('passing_value')\n                #save k\n                previous_k = k\n                previous_edge = (root , k)\n                self.node_gen_2(v,root = root, node_list = node_list,edge_list = edge_list, previous_k = k, previous_edge = previous_edge, graph = graph)\n\n        elif type(data) is list:\n            for item in data:\n                #pprint('passing_data')\n\n                self.node_gen_2(item,root = root, node_list = node_list,edge_list = edge_list,previous_k = previous_k, previous_edge= previous_edge, graph = graph)\n                #create_edge to k\n\n        else:\n            #this item is no longer a dictionary or list\n            pprint('appending_data')\n            #create edge to k\n            if data is not None:\n                graph.add_node(data,type = data)\n                #node_list.append((data, {\"type\" : data}))\n                graph.add_edge(previous_k, data, relationship = \"is\", type = previous_k)\n                #edge_list.append((previous_k ,data,{'relationship': \"is\"}, {'type' : data}))\n                #edge_list.append((root,data))\n\n    #flatten(hierarchak)_dict)\n        return graph \n\n    \n    def node_runner(self,data,graph):\n        \n        node_list = []\n        edge_list = []\n        for item in data:\n            #root = item['title']\n            graph = self.node_gen_2(data = item, node_list = node_list, graph = graph)\n        #pprint(edge_list)\n        return graph\n\n    def node_generator(self, data, root ='title_testing', node_list = [], edge_list = [], previous_k = None, previous_edge = None):\n        #pprint(data)\n        if type(data) is dict:\n            for k, v in data.items():\n                if k is not None and k not in node_list:\n                    node_list.append(k)\n                    edge_list.append((root , k))\n                #pprint('passing_value')\n                #save k\n                previous_k = k\n                previous_edge = (root , k)\n                self.node_generator(v,root = root, node_list = node_list,edge_list = edge_list, previous_k = k, previous_edge = previous_edge)\n\n        elif type(data) is list:\n            for item in data:\n                #pprint('passing_data')\n\n                self.node_generator(item,root = root, node_list = node_list,edge_list = edge_list,previous_k = previous_k, previous_edge= previous_edge)\n                #create_edge to k\n\n        else:\n            #this item is no longer a dictionary or list\n            pprint('appending_data')\n            #create edge to k\n            if data is not None:\n                node_list.append(data)\n                edge_list.append((previous_k ,data))\n                edge_list.append((root,data))\n\n    #flatten(hierarchak)_dict)\n        return node_list, edge_list \n        #self.json_graph = self.create_json_graph()\n\n\n    def create_json_graph(self):\n        #graph = nx.Graph(self.response_json)\n        graph = nx.from_dict_of_dicts(self.response_json)\n        #graph = json_graph.node_link_graph(self.response_json)\n        nx.draw(graph)\n        return graph\n        \n        #self.node_list = self.node_generator`\n\n\n\n    def create_search_result_node(self):\n     \n        for item in self.response_json_flat:\n            for k,v in item.items():\n                if k not in self.column_lookup_table:\n                    column_string = self.colnum_string()\n\n                    self.column_lookup_table[k] = self.colnum_string(self.num_columns)\n                    self.num_columns += 1\n                else:\n                    continue\n\n    def append_to_data_list(self,rnge,d):#rename to _data_list\n        request_body = {\n            'range': rnge,\n            \"majorDimension\": \"COLUMNS\",\n            \"values\": [d]\n        }\n        return request_body\n        #data_list.append(request_body_tmp)\n\n    def map_column_to_range(self,column_key):\n        \n        rnge = \"'Sheet1'\" + \"!\" + column_key + str(1)\n        return rnge\n                \n\n    def colnum_string(self,num_columns):\n        string = \"\"\n        #pprint(\"conlum_string\")\n        #pprint(num_columns)\n        while num_columns > 0:\n            num_columns, remainder = divmod(num_columns - 1, 26)\n            string = chr(65 + remainder) + string\n            #pprint(string)\n        return string\n\n    def map_columns_to_lookup_table(self):\n\n        #print('first_map_columns_print')\n        #num_columns_tmp = self.num_columns\n        #pprint(num_columns_tmp)\n        for item in self.response_json_flat:\n            for k in item.keys():\n                num_columns_tmp = self.num_columns\n                if k not in self.column_lookup_table:\n                    #print('second_map_Columns_print')\n                    #pprint(num_columns_tmp)\n                    self.column_lookup_table[k] = self.colnum_string(num_columns = num_columns_tmp)\n                    self.num_columns = self.num_columns + 1\n       \n                    #append range to request... \n                    #append collumn to batch lookup\n                \n\n                else:\n                    continue\n    \n    def column_request_list_generator(self):\n        request_list = []\n        for k,v in self.column_lookup_table.items():\n            rnge = self.map_column_to_range(k)\n            request_body = self.append_to_data_list(rnge,v)\n            #pprint(request_body)\n            request_list.append(request_body)\n        return request_list\n\n\n\n\n\n        #return column_lookup_table\n\n    def get_next_url(self):\n        return (self.response_json['pagination']['next'])\n\n    def create_search_url(self,base_url,collection,json_parameter,results_per_page,query_param,page_param,page_num):\n        url_sep =\"/\"\n        page_param = page_param +(str(page_num))\n        query = \"&amp;\".join([json_parameter,results_per_page,page_param])\n        query = query_param + query\n        search_url = url_sep.join([base_url,collection,query])\n        #pprint(search_url)\n        \n        return search_url\n\n    def say_hello(self):\n        pprint(self.base_url)\n\n    def request_data(self):\n        headers = {'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.11 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9',\n                    'Accept-Encoding': 'identity'\n                }\n        return requests.get(self.search_url,headers=headers)\n\n    def response_to_json(self):\n        return self.response.json()\n\n    def html_parse(self):\n        soup=BeautifulSoup(self.response.content,'lxml')\n        #pprint(soup)\n        return soup\n\n    def flatten_result(self):\n        flat_result_list = []\n        for item in self.response_json['results']:\n            flat_json = flatten(item)\n            flat_result_list.append(flat_json)\n        return flat_result_list\n\n\n\nclass search_result():\n    \n    def __init__(self,dict_item,num_columns,colnum_string):\n        self.key = dict_item.key()\n        self.value = dict_item.value()\n        self.column_string = colnum_string\n        self.index = num_columns\n        self.range = self.create_column_range_string()\n        self.request_body = self.create_column_request()\n\n    def create_column_request(self):\n        request_body = {\n            'range': self.range,\n            \"majorDimension\": \"COLUMNS\",\n            \"values\": [self.value]\n        }\n        return request_body\n\n    \n    def create_column_range_string(self):\n\n        rnge = \"'Sheet1'\" + \"!\" + self.column_string + str(1)\n        return rnge\n    def colnum_string(self, num_columns):\n        string = \"\"\n        while num_columns > 0:\n            num_columns, remainder = divmod(num_columns - 1, 26)\n            string = chr(65 + remainder) + string\n        return string\n\nclass google_drive:\n    def __init__(self,creds):\n        self.service = self.get_drive_service(creds)\n\n    def test(self):\n        pprint(\"hello I exist\")\n\n    def get_drive_service(self, creds):\n        \"\"\"Shows basic usage of the Drive v3 API.\n        Prints the names and ids of the first 10 files the user has access to.\n        \"\"\"\n        SCOPES = []\n        #creds = None\n        # The file token.json stores the user's access and refresh tokens, and is\n        # created automatically when the authorization flow completes for the first\n        # time.\n\n        service = build('drive', 'v3', credentials=creds)\n\n        # Call the Drive v3 API\n        results = service.files().list(\n            pageSize=10, fields=\"nextPageToken, files(id, name)\").execute()\n        items = results.get('files', [])\n\n        if not items:\n            print('No files found.')\n        else:\n            print('Files:')\n            for item in items:\n                print(u'{0} ({1})'.format(item['name'], item['id']))\n\n        return service\n    \n    \n\n    def create_folder(self,title):\n        drive_service = self.service\n        file_metadata = {\n            'name': '{}'.format(title),\n            'mimeType': 'application/vnd.google-apps.folder'\n        }\n        file = drive_service.files().create(body=file_metadata,\n                                            fields='id').execute()\n        print('Folder ID: %s' % file.get('id'))\n\n\n\n    def add_spreadsheet_to_folder(self ,folder_id,title):\n        drive_service = self.service\n    \n        file_metadata = {\n        'name': '{}'.format(title),\n        'parents': [folder_id],\n        'mimeType': 'application/vnd.google-apps.spreadsheet',\n        }\n\n        res = drive_service.files().create(body=file_metadata).execute()\n        #print(res)\n\n        return res\n\nclass google_sheet():\n\n    def __init__(self,creds):\n        self.service =self.get_sheet_service(creds)\n\n\n    def get_sheet_service(self,creds):\n        service = build('sheets', 'v4', credentials=creds)\n        return service.spreadsheets()\n\nclass google_creds():\n\n    def __init__(self,creds_path):\n\n        self.creds = self.get_creds(creds_path)\n   \n    def get_creds(self,creds_path):\n\n        creds = None\n        # The file token.json stores the user's access and refresh tokens, and is\n        # created automatically when the authorization flow completes for the first\n        # time.\n        if os.path.exists('token.json'):\n            creds = Credentials.from_authorized_user_file('token.json', SCOPES)\n        # If there are no (valid) credentials available, let the user log in.\n        if not creds or not creds.valid:\n            if creds and creds.expired and creds.refresh_token:\n                creds.refresh(Request())\n                print(\"no creds\")\n            else:\n                creds = service_account.Credentials.from_service_account_file(creds_path)\n                #creds = ServiceAccountCredentials.from_json_keyfile_name('add_json_file_here.json', SCOPES)\n                #flow = InstalledAppFlow.from_client_secrets_file(\n                #    'credentials.json', SCOPES)\n                #creds = flow.run_local_server(port=0)\n            # Save the credentials for the next run\n            #with open('token.json', 'w') as token:\n            #    token.write(creds.to_json())\n        return creds\n\nclass config():\n\n    def __init__(self,file_path):\n        #self.yaml_stream = file(\"config.yaml\", 'r')\n        self.data = self.load_config(file_path)\n\n\n    def load_config(self,file_path):\n        #print(\"test\")\n        stream = open(file_path, 'r')\n        data = yaml.load(stream,Loader = Loader)\n        #pprint(data)\n        return data\n\ndef create_google_credentials_object(creds_path = 'credentials.json'):\n    google_credentials_object = google_creds(creds_path)\n    return google_credentials_object\n    \ndef create_config_object(file_path = 'config.yaml'):\n    config_object = config(file_path)\n    return config_object\n\n\ndef search_result_generator(condition = True):\n    #column_lookup_table = {}\n    #pprint(num_columns)\n    page_num = 1\n    column_lookup_table = {}\n    while condition ==True:\n        #pprint(num_columns)\n        time.sleep(61)\n        search_results_page_object = create_search_results_page_object(page_num = page_num)\n        if search_results_page_object.next_url != None:\n            condition = True\n            page_num = page_num + 1            \n            yield (search_results_page_object)\n        else:\n            condition = False\n            yield (search_results_page_object)\n        \ndef create_search_results_page_object(base_url = \"https://www.loc.gov/collections\",collection = \"united-states-reports\",json_parameter = \"fo=json\",results_per_page = \"c=70\",query_param = \"?\",page_param =\"sp=\",page_num = 1):\n    #search = search_results(base_url,collection,json_parameter,results_per_page,query_param,page_param,page_num)\n    #pprint(search.search_url)\n    #pprint(num_columns)\n    return search_results_page(base_url,collection,json_parameter,results_per_page,query_param,page_param,page_num)\n\ndef create_google_drive_object(google_creds):\n    drive_service_object = google_drive(google_creds)\n    return drive_service_object\n\ndef create_google_sheet_object(google_creds):\n    sheet_service_object = google_sheet(google_creds)\n    return sheet_service_object\n\ndef create_new_google_sheet(google_drive_object,folder_id,title):\n    sheet_meta_data = google_drive_object.add_spreadsheet_to_folder(folder_id, title)\n    return sheet_meta_data\n\ndef flatten_result(result_json):\n    flat_json = flatten(result_json)\n    return flat_json\n\ndef write_last_page_num(page_num):\n    with open('last_page_num.txt', 'w') as f:\n        f.write(str(page_num))\n\ndef main():\n    tracemalloc.start()\n    #rate_limiter = RateLimiter(max_calls=1, period=60)\n    #cd to output\n    #result = create_search_results_page_object()\n    #with cd(\"output\"):\n    #    result.write_to_file(data = result.dict_of_dicts, file_num = 1)\n\n    for obj in search_result_generator():   \n        page_num = obj.page_num\n        with cd(\"output_2\"):\n            #print('hahaha')\n            obj.to_json(file_num = page_num)\n            #obj.write_graphml(file_num= page_num)\n            #obj.to_pandas()\n            #obj.write_to_file(data = obj.dict_of_dicts, file_num = page_num)\n            #obj.to_csv()\n        write_last_page_num(page_num)\n        print(\"{} Search Results Crawled\".format(page_num))\n\n\n    \n    snapshot = tracemalloc.take_snapshot()\n    top_stats = snapshot.statistics('lineno')\n    print(\"[ Top 10 ]\")\n    for stat in top_stats[:10]:\n        print(stat)\n\n\nif __name__ == \"__main__\":\n    main()\n\n        \n        \n\n    </code></pre></div>","frontmatter":{"title":"Crawling the Library of Congress API","date":"May 16, 2022","description":"Crawl the Library of Congress API to automate your next research project.","imageAlt":"Justin Napolitano","author":"Justin napolitano","image":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAMAAf/aAAwDAQACEAMQAAABTxTJNBAy/8QAGxAAAwACAwAAAAAAAAAAAAAAAAECAxESEyH/2gAIAQEAAQUCnK2XWzsoXhLOJ//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AUf/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGK/8QAGhAAAgIDAAAAAAAAAAAAAAAAABEBAiAhMf/aAAgBAQAGPwJ23hLOn//EABoQAAMBAQEBAAAAAAAAAAAAAAABESFBkTH/2gAIAQEAAT8hcODeCJk9HwecxGjS+7o11qCqyD//2gAMAwEAAgADAAAAEHDf/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAEDAQE/ENITf//EABcRAQEBAQAAAAAAAAAAAAAAAAERACH/2gAIAQIBAT8QK7kjLv/EABoQAQADAQEBAAAAAAAAAAAAAAEAESExgfD/2gAIAQEAAT8QKxJTYWz7kxIBrXUahSMpwuEBXTTeZyDuoLr2X0hHk//Z"},"images":{"fallback":{"src":"/static/794367035c6138c43c02f27abdaa40e6/20b93/post-image.jpg","srcSet":"/static/794367035c6138c43c02f27abdaa40e6/6cce3/post-image.jpg 750w,\n/static/794367035c6138c43c02f27abdaa40e6/20b93/post-image.jpg 800w","sizes":"100vw"},"sources":[{"srcSet":"/static/794367035c6138c43c02f27abdaa40e6/b56ea/post-image.avif 750w,\n/static/794367035c6138c43c02f27abdaa40e6/ba9bc/post-image.avif 800w","type":"image/avif","sizes":"100vw"},{"srcSet":"/static/794367035c6138c43c02f27abdaa40e6/d2a19/post-image.webp 750w,\n/static/794367035c6138c43c02f27abdaa40e6/56f2e/post-image.webp 800w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6675}}}}},"previous":{"fields":{"slug":"/carbon-shipping-projections/"},"frontmatter":{"title":"Monte Carlo Projection of the Annual Cost of Shipping Carbon from Europe to the United States"}},"next":null},"pageContext":{"id":"c37f105a-dd41-5f18-9dd3-df41400006f2","previousPostId":"e2dd9126-dada-5be9-93d4-aa45f3f139ac","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}